# 개발 계획서: L7 HTTP 요청 감지 시스템

> **PRD 참조**: [03.prd.md](./03.prd.md)
> **작성일**: 2025-01-09
> **상태**: 검토 대기

---

## 1. 설계 결정 사항

PRD 분석 후 확정된 설계 결정:

| 항목 | 결정 | 근거 |
|------|------|------|
| 헬스체크 처리 | **완전히 제외** (메트릭 미수집) | 노이즈 제거, 메트릭 효율성 |
| 경로 정규화 | **고정 Depth 2단계** 제한 | 카디널리티 제어 우선 |
| Depth 초과 표시 | /api/users/* 형식 | 명확한 의미 전달 |
| 파일 구조 | **별도 http_trace.c** 생성 | L4/L7 분리 관리 |
| recvfrom 지원 | **미지원** (read만 구현) | 초기 범위 최소화 |
| Pod 라벨 | **포함** (destination_pod) | 상세 분석 가능 |

---

## 2. Phase 1: L7 HTTP 감지 eBPF 구현

### 2.1 파일 구조

ebpf/
├── tcp_connect.c          # 기존 L4 송신 감지 (변경 없음)
├── http_trace.c           # 신규 L7 HTTP 감지
├── http_trace_types.h     # 공용 타입 정의
└── cmd/agent/
    ├── main.go            # 기존 (L4 핸들러)
    └── http_handler.go    # 신규 (L7 핸들러)

### 2.2 eBPF 맵 정의

#### 2.2.1 http_trace_types.h

c
#ifndef __HTTP_TRACE_TYPES_H__
#define __HTTP_TRACE_TYPES_H__

// accept() 인자 저장용
struct accept_args_t {
    int sockfd;
    struct sockaddr *addr;
};

// read() 인자 저장용
struct read_args_t {
    int fd;
    char *buf;
};

// 소켓 정보 (accept에서 추출)
struct socket_info_t {
    struct sockaddr_in addr;  // 클라이언트 주소
    __u64 accept_time;        // 연결 시각 (ns)
};

// HTTP 이벤트 (User Space 전달용)
struct http_event {
    __u32 saddr;              // Source IP (network order)
    __u32 daddr;              // Destination IP (local)
    __u16 sport;              // Source Port
    __u16 dport;              // Destination Port (listening port)
    __u32 pid;                // Process ID
    char comm[16];            // Process name
    char method[8];           // HTTP Method (GET, POST, etc.)
    char path[64];            // Request Path (Depth 2 제한으로 64바이트 충분)
};

#endif

#### 2.2.2 맵 용량 계산

| 맵 | max_entries | 산정 근거 |
|-----|-------------|-----------|
| active_accept_args_map | 16384 | 동시 accept 대기 수 |
| active_read_args_map | 16384 | 동시 read 호출 수 |
| socket_info_map | 65536 | 노드당 최대 활성 연결 수 |
| http_events (RingBuffer) | 1MB | ~5000 이벤트 버퍼링 |

### 2.3 Tracepoint 구현 상세

#### 2.3.1 sys_enter_accept4 / sys_exit_accept4

**목적**: 새 연결의 클라이언트 IP/Port를 FD와 매핑

**구현 포인트**:
sys_enter_accept4: sockfd, addr 포인터 저장
sys_exit_accept4: 반환된 fd와 함께 socket_info_map에 저장
키 생성: (pid_tgid & 0xFFFFFFFF00000000) | fd

**예외 처리**:
fd < 0: accept 실패, 맵 정리
addr == NULL: 클라이언트 정보 없이 저장 (IP=0.0.0.0)

#### 2.3.2 sys_enter_read / sys_exit_read

**목적**: 소켓에서 읽은 데이터가 HTTP 요청인지 판별

**구현 포인트**:
sys_enter_read:
  - socket_info_map에 해당 fd가 있는지 확인
  - 없으면 무시 (파일/파이프 등)
  - 있으면 read_args_map에 버퍼 포인터 저장

sys_exit_read:
  - bytes_read <= 0: 맵 정리 후 종료
  - 버퍼 첫 8바이트로 HTTP 메서드 판별
  - HTTP면 이벤트 생성 및 RingBuffer 전송

#### 2.3.3 HTTP 메서드 판별 함수

c
static __always_inline bool is_http_request(const char *buf)
{
    // GET, POST, PUT, DELETE, HEAD, PATCH, OPTIONS
    // 첫 4바이트로 빠른 판별
    __u32 first4 = *(__u32 *)buf;

    // Little Endian 기준 비교값
    if (first4 == 0x20544547) return true;  // "GET "
    if (first4 == 0x54534F50) return true;  // "POST"
    if (first4 == 0x20545550) return true;  // "PUT "
    if (first4 == 0x454C4544) return true;  // "DELE"
    if (first4 == 0x44414548) return true;  // "HEAD"
    if (first4 == 0x43544150) return true;  // "PATC"
    if (first4 == 0x4954504F) return true;  // "OPTI"

    return false;
}

#### 2.3.4 HTTP 경로 파싱 함수

c
// PRD 결정: Depth 2 제한, 초과 시 /* 표시
static __always_inline void parse_http_path(
    const char *buf,
    int len,
    char *method_out,  // 8바이트
    char *path_out     // 64바이트
)
{
    // 메서드 추출 (첫 공백까지)
    int i = 0;
    #pragma unroll
    for (; i < 7 && i < len; i++) {
        if (buf[i] == ' ') break;
        method_out[i] = buf[i];
    }
    method_out[i] = '\0';

    // 경로 시작점 찾기
    int path_start = i + 1;

    // 경로 추출 (Depth 2 제한 적용)
    int depth = 0;
    int path_idx = 0;
    int last_slash_idx = -1;

    #pragma unroll
    for (int j = path_start; j < len && path_idx < 63; j++) {
        char c = buf[j];
        if (c == ' ' || c == '?' || c == '#') break;  // 경로 끝

        if (c == '/') {
            depth++;
            if (depth > 2) {
                // Depth 초과: /* 추가 후 종료
                path_out[path_idx++] = '/';
                path_out[path_idx++] = '*';
                break;
            }
            last_slash_idx = path_idx;
        }

        path_out[path_idx++] = c;
    }
    path_out[path_idx] = '\0';
}

### 2.4 작업 목록

| # | 작업 | 예상 시간 | 산출물 |
|---|------|----------|--------|
| 1.1 | http_trace_types.h 작성 | 1h | 헤더 파일 |
| 1.2 | http_trace.c 기본 구조 작성 | 2h | 맵 정의, SEC 선언 |
| 1.3 | accept4 tracepoint 구현 | 3h | 소켓 매핑 로직 |
| 1.4 | read tracepoint 구현 | 4h | HTTP 감지 로직 |
| 1.5 | HTTP 파싱 헬퍼 구현 | 3h | 메서드/경로 추출 |
| 1.6 | bpf2go 생성 스크립트 수정 | 1h | generate.go 수정 |
| 1.7 | 컴파일 및 verifier 통과 테스트 | 2h | .o 파일 생성 확인 |

**Phase 1 총 예상 시간**: 16h

---

## 3. Phase 2: Go L7 핸들러 구현

### 3.1 파일 구조

ebpf/cmd/agent/
├── main.go              # 기존 (수정 필요)
├── http_handler.go      # 신규 HTTP 핸들러
├── path_normalizer.go   # 경로 정규화 로직
└── filter.go            # 헬스체크 필터 (기존 확장)

### 3.2 HTTP 핸들러 구조

go
// http_handler.go

type HTTPEvent struct {
    SrcIP    net.IP
    DstIP    net.IP
    SrcPort  uint16
    DstPort  uint16
    PID      uint32
    Comm     string
    Method   string
    Path     string
}

type HTTPHandler struct {
    reader          *ringbuf.Reader
    mapper          *k8smapper.Mapper
    counter         *prometheus.CounterVec
    healthFilter    *HealthCheckFilter
    pathNormalizer  *PathNormalizer
}

func (h *HTTPHandler) Run(ctx context.Context) error {
    for {
        record, err := h.reader.Read()
        if err != nil {
            if errors.Is(err, ringbuf.ErrClosed) {
                return nil
            }
            continue
        }

        event := h.parseEvent(record.RawSample)
        h.processEvent(event)
    }
}

func (h *HTTPHandler) processEvent(event *HTTPEvent) {
    // 1. 헬스체크 필터링 (완전 제외)
    if h.healthFilter.IsHealthCheck(event.Path) {
        return  // 메트릭 수집 안함
    }

    // 2. 경로 정규화 (Depth 2 제한은 eBPF에서 처리됨)
    //    추가 정규화 필요시 여기서 처리
    normalizedPath := h.pathNormalizer.Normalize(event.Path)

    // 3. K8s 매핑
    destMeta, _ := h.mapper.Lookup(event.DstIP.String())

    // 4. 메트릭 증가
    h.counter.WithLabelValues(
        event.SrcIP.String(),
        destMeta.Namespace,
        destMeta.Service,
        destMeta.Pod,
        event.Method,
        normalizedPath,
        event.Comm,
    ).Inc()
}

### 3.3 헬스체크 필터

go
// filter.go

type HealthCheckFilter struct {
    patterns []string
}

var defaultHealthCheckPatterns = []string{
    "/healthz",
    "/readyz",
    "/livez",
    "/health",
    "/ready",
    "/live",
    "/ping",
    "/status",
    "/_health",
}

func NewHealthCheckFilter(customPatterns string) *HealthCheckFilter {
    patterns := defaultHealthCheckPatterns
    if customPatterns != "" {
        for _, p := range strings.Split(customPatterns, ",") {
            p = strings.TrimSpace(p)
            if p != "" {
                patterns = append(patterns, p)
            }
        }
    }
    return &HealthCheckFilter{patterns: patterns}
}

func (f *HealthCheckFilter) IsHealthCheck(path string) bool {
    pathLower := strings.ToLower(path)
    for _, pattern := range f.patterns {
        if strings.HasPrefix(pathLower, pattern) {
            return true
        }
    }
    return false
}

### 3.4 경로 정규화 (Go측 추가 처리)

go
// path_normalizer.go

type PathNormalizer struct {
    maxDepth int  // 환경변수로 설정 가능
}

func NewPathNormalizer(maxDepth int) *PathNormalizer {
    if maxDepth <= 0 {
        maxDepth = 2  // 기본값
    }
    return &PathNormalizer{maxDepth: maxDepth}
}

// eBPF에서 이미 Depth 제한이 적용되므로
// Go에서는 추가 정규화만 수행 (필요시)
func (n *PathNormalizer) Normalize(path string) string {
    // 이미 eBPF에서 /* 처리됨
    // 추가로 필요한 정규화가 있다면 여기서 처리

    // 예: 빈 경로 처리
    if path == "" || path == "/" {
        return "/"
    }

    return path
}

### 3.5 main.go 수정 사항

go
// main.go 수정 포인트

func main() {
    // ... 기존 코드 ...

    // L7 HTTP 활성화 여부 확인
    enableL7 := os.Getenv("ENABLE_L7_HTTP") == "true"

    if enableL7 {
        // HTTP eBPF 오브젝트 로드
        var httpObjs httptraceObjects
        if err := loadHttptraceObjects(&httpObjs, nil); err != nil {
            log.Fatalf("failed to load HTTP BPF objects: %v", err)
        }
        defer httpObjs.Close()

        // Tracepoint 연결
        tpAcceptEnter, _ := link.Tracepoint("syscalls", "sys_enter_accept4",
            httpObjs.SysEnterAccept4, nil)
        defer tpAcceptEnter.Close()

        tpAcceptExit, _ := link.Tracepoint("syscalls", "sys_exit_accept4",
            httpObjs.SysExitAccept4, nil)
        defer tpAcceptExit.Close()

        tpReadEnter, _ := link.Tracepoint("syscalls", "sys_enter_read",
            httpObjs.SysEnterRead, nil)
        defer tpReadEnter.Close()

        tpReadExit, _ := link.Tracepoint("syscalls", "sys_exit_read",
            httpObjs.SysExitRead, nil)
        defer tpReadExit.Close()

        // HTTP 핸들러 시작
        httpHandler := NewHTTPHandler(httpObjs.HttpEvents, mapper, httpCounter)
        go httpHandler.Run(ctx)
    }

    // ... 기존 코드 ...
}

### 3.6 작업 목록

| # | 작업 | 예상 시간 | 산출물 |
|---|------|----------|--------|
| 2.1 | http_handler.go 구현 | 4h | RingBuffer 리더, 이벤트 파싱 |
| 2.2 | filter.go 헬스체크 필터 구현 | 2h | 필터 로직 |
| 2.3 | path_normalizer.go 구현 | 1h | 경로 정규화 |
| 2.4 | main.go 수정 (L7 통합) | 3h | 초기화 로직 |
| 2.5 | HTTPEvent 구조체 파싱 구현 | 2h | 바이트 변환 |

**Phase 2 총 예상 시간**: 12h

---

## 4. Phase 3: L7 메트릭 통합

### 4.1 메트릭 정의

go
// 신규 메트릭
httpCounter := prometheus.NewCounterVec(
    prometheus.CounterOpts{
        Name: "internal_http_requests_total",
        Help: "Count of HTTP requests to Pods (healthcheck excluded)",
    },
    []string{
        "source_ip",              // 요청자 IP
        "destination_namespace",  // 수신 Pod 네임스페이스
        "destination_service",    // 수신 Service 이름
        "destination_pod",        // 수신 Pod 이름
        "method",                 // HTTP 메서드
        "path",                   // 요청 경로 (Depth 2 제한)
        "process_comm",           // 수신 프로세스명
    },
)

### 4.2 카디널리티 분석

| 라벨 | 예상 카디널리티 | 비고 |
|------|----------------|------|
| source_ip | ~1000 | 클러스터 내부 Pod + 외부 |
| destination_namespace | ~10 | 네임스페이스 수 |
| destination_service | ~50 | 서비스 수 |
| destination_pod | ~200 | Pod Replica 수 |
| method | 7 | GET,POST,PUT,DELETE,HEAD,PATCH,OPTIONS |
| path | ~100 | Depth 2 제한으로 감소 |
| process_comm | ~20 | 서버 프로세스 종류 |

**최악의 경우 조합**: 1000 × 10 × 50 × 200 × 7 × 100 × 20 = 매우 큼

**실제 예상**: 활성 조합만 생성되므로 ~10,000 시리즈 이내 예상

### 4.3 환경변수 설정

yaml
env:
  # L7 HTTP 감지 활성화 (기본: false)
  - name: ENABLE_L7_HTTP
    value: "true"

  # 커스텀 헬스체크 경로 추가 (기본 패턴 외)
  - name: HEALTHCHECK_PATHS
    value: "/custom-health,/app-status"

  # 경로 Depth 제한 (기본: 2)
  - name: PATH_MAX_DEPTH
    value: "2"

### 4.4 작업 목록

| # | 작업 | 예상 시간 | 산출물 |
|---|------|----------|--------|
| 3.1 | Prometheus Counter 등록 | 1h | 메트릭 정의 |
| 3.2 | 환경변수 파싱 로직 | 2h | 설정 처리 |
| 3.3 | DaemonSet YAML 업데이트 | 1h | manifest 수정 |
| 3.4 | 메트릭 엔드포인트 테스트 | 1h | /metrics 확인 |

**Phase 3 총 예상 시간**: 5h

---

## 5. Phase 4: 테스트 및 문서화

### 5.1 단위 테스트

| 테스트 | 설명 | 파일 |
|--------|------|------|
| TestIsHealthCheck | 헬스체크 경로 판별 | filter_test.go |
| TestPathNormalize | 경로 정규화 | path_normalizer_test.go |
| TestHTTPEventParse | 이벤트 파싱 | http_handler_test.go |

### 5.2 통합 테스트

yaml
# 테스트 시나리오
1. DaemonSet 배포
2. 테스트 Pod에서 HTTP 요청 발생
   - curl http://service/api/users
   - curl http://service/healthz
   - curl http://service/api/users/123/orders/456
3. 메트릭 확인
   - /api/users 경로 카운트 증가 확인
   - /healthz 메트릭 없음 확인
   - /api/users/* 경로 확인 (Depth 초과)

### 5.3 성능 벤치마크

bash
# 벤치마크 항목
1. CPU 오버헤드: L7 활성화 전/후 비교
2. 메모리 사용량: RingBuffer 크기별 측정
3. 이벤트 처리량: 초당 HTTP 요청 처리량
4. 지연 시간: HTTP 요청-메트릭 반영 시간

### 5.4 문서화

| 문서 | 내용 |
|------|------|
| README.md | L7 기능 설명, 설정 방법 |
| METRICS.md | 메트릭 스키마, 쿼리 예시 |
| CHANGELOG.md | 버전 변경 이력 |

### 5.5 작업 목록

| # | 작업 | 예상 시간 | 산출물 |
|---|------|----------|--------|
| 4.1 | 단위 테스트 작성 | 4h | *_test.go |
| 4.2 | 통합 테스트 작성 | 3h | 테스트 시나리오 |
| 4.3 | 성능 벤치마크 | 4h | 벤치마크 결과 |
| 4.4 | README 업데이트 | 2h | 문서 |
| 4.5 | METRICS.md 작성 | 1h | 메트릭 문서 |

**Phase 4 총 예상 시간**: 14h

---

## 6. 전체 일정 요약

| Phase | 작업 내용 | 예상 시간 |
|-------|----------|----------|
| Phase 1 | L7 HTTP 감지 eBPF 구현 | 16h |
| Phase 2 | Go L7 핸들러 구현 | 12h |
| Phase 3 | L7 메트릭 통합 | 5h |
| Phase 4 | 테스트 및 문서화 | 14h |
| **합계** | | **47h** |

---

## 7. 리스크 및 완화 방안

| 리스크 | 영향 | 완화 방안 |
|--------|------|-----------|
| eBPF verifier 거부 | Phase 1 지연 | 루프 언롤, 조건부 반환 최적화 |
| 이벤트 볼륨 과다 | CPU 오버헤드 | 샘플링 옵션, 조기 필터링 |
| 카디널리티 폭발 | Prometheus 부하 | Depth 제한, 라벨 최소화 |
| 멀티 read() 요청 | 파싱 실패 | 첫 read()만 처리 (known limitation) |

---

## 8. 미결정 사항 (추후 검토)

현재 개발 계획에 포함되지 않은 향후 검토 사항:

1. **HTTPS 트래픽 처리**
   - TLS 복호화 없이는 페이로드 파싱 불가
   - 옵션: L4 메트릭만 수집, is_tls=true 라벨 추가

2. **HTTP/2, gRPC 지원**
   - 바이너리 프로토콜 파싱 필요
   - 별도 Phase로 분리 권장

3. **source_namespace/source_pod 역매핑**
   - 현재: source_ip만 수집
   - 추가 시: k8smapper에서 역방향 조회 필요

4. **샘플링 옵션**
   - 고트래픽 환경에서 전수 수집이 부담될 경우
   - 옵션: SAMPLE_RATE 환경변수로 1/N 샘플링

---

## 변경 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|----------|
| 0.1 | 2025-01-09 | 초안 작성 |
