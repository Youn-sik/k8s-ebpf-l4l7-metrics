# PRD-03: L7 HTTP 요청 감지를 통한 수신 트래픽 메트릭

## 배경

- 현재 에이전트는 `kprobe/tcp_v4_connect`로 **송신(outbound)** TCP 연결만 감지함.
- 다음과 같은 관찰 영역이 누락됨:
  - **외부 → Pod**: 클러스터 외부에서 들어오는 트래픽
  - **HTTP 경로 기반 분석**: 어떤 API 엔드포인트가 호출되는지 파악
  - **헬스체크 필터링**: Kubernetes Liveness/Readiness 프로브 트래픽 구분

## 목표

1. **L7 HTTP 요청 감지**: Pod로 들어오는 HTTP 요청의 메서드와 경로를 감지한다.
2. **헬스체크 필터링**: `/healthz`, `/ready` 등 헬스체크 경로를 식별하여 별도 처리한다.
3. **별도 메트릭 노출**: 기존 송신 메트릭과 분리된 HTTP 수신 메트릭을 제공한다.
4. **기존 기능 유지**: 송신 감지(tcp_v4_connect)는 그대로 유지하여 scale-from-zero 기능을 보장한다.

## 기술 설계

### 1. Hook Point 선정

| 옵션 | 장점 | 단점 | 채택 여부 |
|------|------|------|-----------|
| `tracepoint/syscalls/sys_enter_read` + `sys_exit_read` | HTTP 페이로드 접근 가능, 검증된 방식 (Pixie, Datadog 등) | 이벤트 볼륨 높음, FD-소켓 매핑 필요 | **채택** |
| `tracepoint/syscalls/sys_enter_recvfrom` + `sys_exit_recvfrom` | UDP/TCP 모두 지원 | read와 유사한 구현 필요 | **보조 채택** |
| `kprobe/tcp_recvmsg` | 커널 레벨 직접 접근 | skb 파싱 복잡, verifier 제약 | 미채택 |
| Socket Filter (`BPF_PROG_TYPE_SOCKET_FILTER`) | 패킷 레벨 접근 | Pod별 소켓 attach 필요, 관리 복잡 | 미채택 |

### 2. 아키텍처 설계

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              Node (Host)                                 │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                         Kernel Space                               │  │
│  │                                                                    │  │
│  │  ┌─────────────────┐              ┌─────────────────────────────┐  │  │
│  │  │ tcp_v4_connect  │              │ sys_enter_accept4           │  │  │
│  │  │    (L4 송신)    │              │ sys_exit_accept4            │  │  │
│  │  │    kprobe       │              │ sys_enter_read              │  │  │
│  │  │    (기존)       │              │ sys_exit_read               │  │  │
│  │  └───────┬─────────┘              │ (L7 HTTP) tracepoint        │  │  │
│  │          │                        └──────────────┬──────────────┘  │  │
│  │          ▼                                       ▼                 │  │
│  │  ┌─────────────────────────────────────────────────────────────┐  │  │
│  │  │                    RingBuffer Maps                          │  │  │
│  │  │          events (기존)  │  http_events (신규)               │  │  │
│  │  └─────────────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                    │                                     │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                         User Space (Go)                            │  │
│  │                                                                    │  │
│  │  ┌─────────────────┐              ┌─────────────────────────┐     │  │
│  │  │  Outbound       │              │     HTTP Handler        │     │  │
│  │  │  Handler (기존) │              │  ┌─────────────────┐    │     │  │
│  │  │   (L4)          │              │  │  HTTP Parser    │    │     │  │
│  │  └───────┬─────────┘              │  │  Method/Path    │    │     │  │
│  │          │                        │  └────────┬────────┘    │     │  │
│  │          │                        │           │             │     │  │
│  │          │                        │  ┌────────▼────────┐    │     │  │
│  │          │                        │  │ Health Check    │    │     │  │
│  │          │                        │  │ Filter          │    │     │  │
│  │          │                        │  │ /healthz,/ready │    │     │  │
│  │          │                        │  └────────┬────────┘    │     │  │
│  │          │                        └───────────┼─────────────┘     │  │
│  │          ▼                                    ▼                   │  │
│  │  ┌─────────────────────────────────────────────────────────────┐  │  │
│  │  │                  Prometheus Metrics                         │  │  │
│  │  │  internal_tcp_attempts_total (L4, 기존)                     │  │  │
│  │  │  internal_http_requests_total (L7, 신규)                    │  │  │
│  │  └─────────────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3. eBPF 데이터 구조체

```c
// 소켓 연결 추적용 맵
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 65536);
    __type(key, u64);                    // pid_tgid
    __type(value, struct accept_args_t);
} active_accept_args_map SEC(".maps");

// read 시스템콜 인자 추적용 맵
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 65536);
    __type(key, u64);                    // pid_tgid
    __type(value, struct read_args_t);
} active_read_args_map SEC(".maps");

// FD → 소켓 정보 매핑
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 65536);
    __type(key, u64);                    // pid_tgid << 32 | fd
    __type(value, struct socket_info_t);
} socket_info_map SEC(".maps");

// HTTP 이벤트 구조체
struct http_event {
    __u32 saddr;              // Source IP
    __u32 daddr;              // Destination IP
    __u16 sport;              // Source Port
    __u16 dport;              // Destination Port
    __u32 pid;                // Process ID
    char comm[16];            // Process name
    char method[8];           // HTTP Method (GET, POST, etc.)
    char path[128];           // Request Path
    __u8 is_request;          // 1: Request, 0: Response
    __u16 status_code;        // HTTP Status Code (응답 시)
};

// HTTP 이벤트용 RingBuffer
struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 1024 * 1024);  // 1MB
} http_events SEC(".maps");
```

### 4. Tracepoint 구현

```c
// accept 시스템콜 진입 - 소켓 연결 추적 시작
SEC("tracepoint/syscalls/sys_enter_accept4")
int sys_enter_accept4(struct trace_event_raw_sys_enter *ctx)
{
    u64 id = bpf_get_current_pid_tgid();
    struct accept_args_t args = {};
    args.sockfd = (int)ctx->args[0];
    args.addr = (struct sockaddr *)ctx->args[1];
    bpf_map_update_elem(&active_accept_args_map, &id, &args, BPF_ANY);
    return 0;
}

// accept 시스템콜 종료 - FD-소켓 매핑 저장
SEC("tracepoint/syscalls/sys_exit_accept4")
int sys_exit_accept4(struct trace_event_raw_sys_exit *ctx)
{
    u64 id = bpf_get_current_pid_tgid();
    int fd = (int)ctx->ret;
    if (fd < 0) {
        bpf_map_delete_elem(&active_accept_args_map, &id);
        return 0;
    }

    struct accept_args_t *args = bpf_map_lookup_elem(&active_accept_args_map, &id);
    if (args && args->addr) {
        // 소켓 정보를 socket_info_map에 저장
        u64 key = (id & 0xFFFFFFFF00000000) | fd;
        struct socket_info_t info = {};
        bpf_probe_read_user(&info.addr, sizeof(info.addr), args->addr);
        bpf_map_update_elem(&socket_info_map, &key, &info, BPF_ANY);
    }
    bpf_map_delete_elem(&active_accept_args_map, &id);
    return 0;
}

// read 시스템콜 진입 - 버퍼 포인터 저장
SEC("tracepoint/syscalls/sys_enter_read")
int sys_enter_read(struct trace_event_raw_sys_enter *ctx)
{
    u64 id = bpf_get_current_pid_tgid();
    int fd = (int)ctx->args[0];

    // 소켓 FD인지 확인
    u64 key = (id & 0xFFFFFFFF00000000) | fd;
    if (!bpf_map_lookup_elem(&socket_info_map, &key)) {
        return 0;  // 소켓이 아니면 무시
    }

    struct read_args_t args = {};
    args.fd = fd;
    args.buf = (char *)ctx->args[1];
    bpf_map_update_elem(&active_read_args_map, &id, &args, BPF_ANY);
    return 0;
}

// read 시스템콜 종료 - HTTP 데이터 파싱
SEC("tracepoint/syscalls/sys_exit_read")
int sys_exit_read(struct trace_event_raw_sys_exit *ctx)
{
    u64 id = bpf_get_current_pid_tgid();
    ssize_t bytes_read = ctx->ret;

    if (bytes_read <= 0) {
        bpf_map_delete_elem(&active_read_args_map, &id);
        return 0;
    }

    struct read_args_t *args = bpf_map_lookup_elem(&active_read_args_map, &id);
    if (!args) return 0;

    // HTTP 요청인지 확인 (GET, POST, PUT, DELETE, HEAD, OPTIONS, PATCH)
    char buf[8];
    bpf_probe_read_user(buf, sizeof(buf), args->buf);

    if (!is_http_request(buf)) {
        bpf_map_delete_elem(&active_read_args_map, &id);
        return 0;
    }

    // HTTP 이벤트 생성 및 전송
    struct http_event *e = bpf_ringbuf_reserve(&http_events, sizeof(*e), 0);
    if (!e) {
        bpf_map_delete_elem(&active_read_args_map, &id);
        return 0;
    }

    // 소켓 정보에서 IP/Port 추출
    u64 sock_key = (id & 0xFFFFFFFF00000000) | args->fd;
    struct socket_info_t *sock = bpf_map_lookup_elem(&socket_info_map, &sock_key);
    if (sock) {
        e->saddr = sock->addr.sin_addr.s_addr;
        e->sport = sock->addr.sin_port;
        // daddr, dport는 로컬 소켓 정보에서 추출
    }

    e->pid = id >> 32;
    bpf_get_current_comm(&e->comm, sizeof(e->comm));
    e->is_request = 1;

    // HTTP 메서드 및 경로 파싱
    parse_http_request(args->buf, bytes_read, e->method, e->path);

    bpf_ringbuf_submit(e, 0);
    bpf_map_delete_elem(&active_read_args_map, &id);
    return 0;
}

// HTTP 요청 여부 판별 헬퍼
static __always_inline bool is_http_request(const char *buf)
{
    // GET, POST, PUT, DELETE, HEAD, OPTIONS, PATCH 체크
    if (buf[0] == 'G' && buf[1] == 'E' && buf[2] == 'T' && buf[3] == ' ')
        return true;
    if (buf[0] == 'P' && buf[1] == 'O' && buf[2] == 'S' && buf[3] == 'T')
        return true;
    if (buf[0] == 'P' && buf[1] == 'U' && buf[2] == 'T' && buf[3] == ' ')
        return true;
    if (buf[0] == 'D' && buf[1] == 'E' && buf[2] == 'L' && buf[3] == 'E')
        return true;
    if (buf[0] == 'H' && buf[1] == 'E' && buf[2] == 'A' && buf[3] == 'D')
        return true;
    return false;
}
```

### 5. 메트릭 설계

```text
# HELP internal_http_requests_total Total count of HTTP requests to Pods
# TYPE internal_http_requests_total counter
internal_http_requests_total{
    source_ip="10.244.1.5",
    destination_namespace="default",
    destination_service="backend-api",
    destination_pod="backend-api-abc123",
    method="GET",
    path="/api/users",
    is_healthcheck="false",
    process_comm="nginx"
} 156

# 헬스체크 요청 별도 집계
internal_http_requests_total{
    source_ip="10.0.1.10",
    destination_namespace="default",
    destination_service="backend-api",
    destination_pod="backend-api-abc123",
    method="GET",
    path="/healthz",
    is_healthcheck="true",
    process_comm="nginx"
} 1024
```

### 6. Go 핸들러 구현

```go
// 헬스체크 경로 패턴
var healthCheckPatterns = []string{
    "/healthz",
    "/readyz",
    "/livez",
    "/health",
    "/ready",
    "/live",
    "/ping",
    "/status",
    "/_health",
}

func isHealthCheckPath(path string) bool {
    pathLower := strings.ToLower(path)
    for _, pattern := range healthCheckPatterns {
        if strings.HasPrefix(pathLower, pattern) {
            return true
        }
    }
    return false
}

// HTTP 이벤트 처리
func (h *HTTPHandler) processEvent(event *HTTPEvent) {
    isHealthCheck := isHealthCheckPath(event.Path)

    // 헬스체크 필터링이 활성화되고 헬스체크인 경우 스킵
    if h.filterHealthCheck && isHealthCheck {
        return
    }

    // 메트릭 증가
    h.counter.WithLabelValues(
        event.SourceIP,
        event.DestNamespace,
        event.DestService,
        event.DestPod,
        event.Method,
        normalizePath(event.Path),  // /api/users/123 → /api/users/:id
        strconv.FormatBool(isHealthCheck),
        event.Comm,
    ).Inc()
}
```

## 설정 옵션

```yaml
# DaemonSet 환경변수
env:
  # L7 HTTP 감지 활성화 (기본: false)
  - name: ENABLE_L7_HTTP
    value: "true"

  # 헬스체크 필터링 (기본: true)
  - name: FILTER_HEALTHCHECK
    value: "true"

  # 커스텀 헬스체크 경로 추가
  - name: HEALTHCHECK_PATHS
    value: "/healthz,/ready,/live,/ping,/custom-health"

  # 경로 정규화 활성화 (기본: true)
  # /api/users/123 → /api/users/:id
  - name: NORMALIZE_PATHS
    value: "true"

  # 캡처할 최대 경로 길이 (기본: 128)
  - name: MAX_PATH_LENGTH
    value: "128"
```

## 성능 고려사항

| 항목 | 영향 | 완화 방안 |
|------|------|-----------|
| **이벤트 볼륨** | 높음 - 모든 read() 호출 추적 | 소켓 FD 필터링으로 비소켓 read 제외 |
| **CPU 오버헤드** | ~5-15% 증가 예상 | 샘플링 옵션 제공, 필요 시 비활성화 가능 |
| **메모리 사용량** | RingBuffer 1MB 추가 | 설정 가능한 버퍼 크기 |
| **경로 카디널리티** | 메트릭 폭발 위험 | 경로 정규화 필수 적용 |

## 제약 사항

1. **HTTPS 트래픽**
   - TLS 암호화된 트래픽은 페이로드 파싱 불가
   - HTTPS는 L4 메트릭만 수집 (별도 라벨로 구분)

2. **멀티 패킷 요청**
   - 대형 HTTP 요청이 여러 read()에 걸쳐 수신될 경우
   - 첫 번째 read()에서 메서드/경로 추출 시도

3. **HTTP/2, gRPC**
   - 바이너리 프로토콜로 단순 텍스트 파싱 불가
   - 별도 프로토콜 핸들러 필요 (향후 확장)

4. **eBPF Verifier 제약**
   - 문자열 비교 루프 제한
   - 경로 파싱 최대 길이 제한 (128바이트)

## 작업 항목

### Phase 1: L7 HTTP 감지 eBPF 구현
1. `socket_info_map`, `active_read_args_map` 등 맵 정의
2. `sys_enter_accept4`, `sys_exit_accept4` tracepoint 구현
3. `sys_enter_read`, `sys_exit_read` tracepoint 구현
4. HTTP 메서드/경로 파싱 헬퍼 함수 구현
5. bpf2go 산출물 재생성

### Phase 2: Go L7 핸들러 구현
1. HTTP RingBuffer 리더 추가
2. 헬스체크 경로 필터링 로직
3. 경로 정규화 로직 (`/api/users/123` → `/api/users/:id`)
4. 카디널리티 제어 (상위 N개 경로만 개별 라벨)

### Phase 3: L7 메트릭 통합
1. `internal_http_requests_total` Counter 등록
2. Cardinality 폭발 방지 로직
3. 설정 옵션 (ENABLE_L7_HTTP, FILTER_HEALTHCHECK 등)

### Phase 4: L7 테스트 및 문서화
1. HTTP 파싱 단위 테스트
2. 헬스체크 필터링 테스트
3. 성능 벤치마크 (with/without L7)
4. README 업데이트

## 참고 자료

- [Pixie HTTP Tracing](https://blog.px.dev/ebpf-http-tracing/)
- [Datadog eBPF Guide](https://www.datadoghq.com/blog/ebpf-guide/)
- [eunomia L7 Tracing Tutorial](https://eunomia.dev/tutorials/23-http/)
- [Cilium Hubble L7 Visibility](https://docs.cilium.io/en/latest/observability/visibility.html)
